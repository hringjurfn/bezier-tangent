{
  "version": 3,
  "sources": ["src/global.js", "src/math.js", "src/node/node.js", "src/node/group.js", "src/node/primitives.js", "src/node/bezier.js", "src/node/index.js", "src/scene.js", "src/render.js", "src/main.js"],
  "sourcesContent": ["const GlobalContext = (\n  typeof global != 'undefined' ? global :\n  typeof window != 'undefined' ? window :\n  this || {}\n)\n\nconst log = console.log.bind(console)\nconst dlog = DEBUG ? console.log.bind(console) : function(){}\n\nconst $$ = (q, e) => Array.prototype.slice.call((e || document).querySelectorAll(q))\nconst $  = (q, e) => (e || document).querySelector(q)\n\n\nclass EventEmitter {\n  constructor() {\n    this._events = new Map() // <keyof EventMap,Set<EventHandler>>\n  }\n\n  on(event, handler) { return this.addEventListener(event, handler) }\n  off(event, handler) { return this.removeEventListener(event, handler) }\n\n  addEventListener(event, handler) {\n    // Returns the number of handlers registered for event, after adding handler.\n    let s = this._events.get(event)\n    if (s) {\n      s.add(handler)\n    } else {\n      s = new Set([handler])\n      this._events.set(event, s)\n    }\n    return s.size\n  }\n\n  removeEventListener(event, handler) {\n    // Returns the number of handlers registered for event, after removing handler.\n    // Returns -1 if handler was not registered for the event.\n    let s = this._events.get(event)\n    if (!s || !s.delete(handler)) {\n      return -1\n    }\n    if (s.size == 0) {\n      this._events.delete(event)\n    }\n    return s.size\n  }\n\n  dispatchEvent(event, data) {\n    let s = this._events.get(event)\n    if (s) for (let handler of s) {\n      handler(data)\n    }\n  }\n}\n\n\nfunction _stackTrace(cons) {\n  const x = {stack:''}\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(x, cons)\n    const p = x.stack.indexOf('\\n')\n    if (p != -1) {\n      return x.stack.substr(p+1)\n    }\n  }\n  return x.stack\n}\n\n// _parseStackFrame(sf :string) : StackFrameInfo | null\n// interface StackFrameInfo {\n//   func :string\n//   file :string\n//   line :int\n//   col  :int\n// }\n//\nfunction _parseStackFrame(sf) {\n  let m = /\\s*at\\s+(?:[^\\s]+\\.|)([^\\s\\.]+)\\s+(?:\\[as ([^\\]]+)\\]\\s+|)\\((?:.+[\\/ ](src\\/[^\\:]+)|([^\\:]*))(?:\\:(\\d+)\\:(\\d+)|.*)\\)/.exec(sf)\n  // 1: name\n  // 2: as-name | undefined\n  // 3: src-filename\n  // 4: filename\n  // 5: line\n  // 6: column\n  //\n  if (m) {\n    return {\n      func: m[2] || m[1],\n      file: m[3] || m[4],\n      line: m[5] ? parseInt(m[5]) : 0,\n      col:  m[6] ? parseInt(m[6]) : 0,\n    }\n  } else {\n    console.log(\"failed to parse stack frame\", JSON.stringify(sf))\n  }\n  return null\n}\n\nfunction assert() {\n  if (DEBUG) {\n    let cond = arguments[0], msg = arguments[1], cons = (arguments[2] || assert)\n    if (!cond) {\n      let stack = _stackTrace(cons)\n      let message = 'assertion failure: ' + (msg || cond)\n      if (!assert.throws && typeof process != 'undefined') {\n        console.error(message + \"\\n\" + stack)\n        process.exit(3)\n      } else {\n        let e = new Error(message)\n        e.name = 'AssertionError'\n        e.stack = stack\n        throw e\n      }\n    }\n  }\n}\n\n\n// export as globals since local names are mangled by esbuild\nGlobalContext[\"GlobalContext\"] = GlobalContext\nGlobalContext[\"log\"] = log\nGlobalContext[\"dlog\"] = dlog\nGlobalContext[\"$\"] = $\nGlobalContext[\"$$\"] = $$\nGlobalContext[\"EventEmitter\"] = EventEmitter\nGlobalContext[\"assert\"] = assert\n", "export function rad2deg(radians) {\n  return radians * (180 / Math.PI)\n}\n\nexport function deg2rad(degrees) {\n  return degrees * (Math.PI / 180)\n}\n\n\nexport class Rect {\n  constructor(x, y, width, height) {\n    this.x = x\n    this.y = y\n    this.width = width\n    this.height = height\n  }\n\n  containsPoint(v) {\n    return (\n      v.x >= this.x && v.x <= this.x + this.width &&\n      v.y >= this.y && v.y <= this.y + this.width\n    )\n  }\n\n  translate(v) {\n    return new Rect(this.x + v.x, this.y + v.y, this.width, this.height)\n  }\n\n  toString() {\n    return `(${this.x}, ${this.y}, ${this.width}, ${this.height})`\n  }\n}\n\n\nexport class Vec /*extends Array*/ {\n  constructor(x, y) {\n    // super(x, y)\n    this.x = x\n    this.y = y\n  }\n\n  distanceTo(v) { // euclidean distance between this and v\n    return Math.sqrt(this.squaredDistanceTo(v))\n  }\n\n  squaredDistanceTo(v){\n    let x = this.x - v.x\n    let y = this.y - v.y\n    return x * x + y * y\n  }\n\n  angleTo(v) { // angle from this to v in radians\n    return Math.atan2(this.y - v.y, this.x - v.x) + Math.PI\n  }\n\n  // LERP - Linear intERPolation between this and v\n  lerp(v, t) {\n    let a = this, ax = a.x, ay = a.y\n    return vec(ax + t * (v.x - ax), ay + t * (v.y - ay))\n  }\n\n  isInside(vmin, vmax) {\n    return v.x >= vmin.x && v.x <= vmax.x && v.y >= vmin.y && v.y <= vmax.y\n  }\n\n  copy() {\n    return new Vec(this.x, this.y)\n  }\n\n  sub(v) {\n    return (typeof v == \"number\" ?\n      new Vec(this.x - v, this.y - v) :\n      new Vec(this.x - v.x, this.y - v.y) )\n  }\n  add(v) {\n    return (typeof v == \"number\" ?\n      new Vec(this.x + v, this.y + v) :\n      new Vec(this.x + v.x, this.y + v.y) )\n  }\n  mul(v) {\n    return (typeof v == \"number\" ?\n      new Vec(this.x * v, this.y * v) :\n      new Vec(this.x * v.x, this.y * v.y) )\n  }\n  div(v) {\n    return (typeof v == \"number\" ?\n      new Vec(this.x / v, this.y / v) :\n      new Vec(this.x / v.x, this.y / v.y) )\n  }\n\n  toString() {\n    return `(${this.x}, ${this.y})`\n  }\n}\n\nexport function vec(x, y) {\n  return new Vec(x, y)\n}\n", "import { vec, Rect } from \"../math\"\n\n\nexport class Stroke {\n  constructor(color, weight) {\n    this.color = color\n    this.weight = weight\n  }\n}\nStroke.default = new Stroke(\"black\", 1)\n\n\nexport class Node extends EventEmitter {\n  constructor(position) {\n    super()\n    this.parent = null\n    this.position = position || vec(0,0)\n    this._bounds = new Rect(0,0,0,0)\n    this.visible = true\n    this.transform = null  // optional matrix\n    this.needsRecompute = true  // true when recompute() needs to be called on next update\n  }\n\n  dirty() {\n    this.needsRecompute = true\n  }\n\n  recompute() {\n    // Called when first-level properties has changed. Recompute derived data like bounds.\n    this.needsRecompute = false\n    this._bounds.x = this.position.x\n    this._bounds.y = this.position.y\n  }\n\n  get bounds() {\n    if (this.needsRecompute) {\n      this.recompute()\n    }\n    return this._bounds\n  }\n\n  updateAndDraw(g, time) {\n    // Called by renderer each frame. Don't override this; instead override update() and draw().\n    if (this.visible) {\n      if (this.needsRecompute) {\n        this.recompute()\n      }\n      this.update(time, g)\n      this.draw(g, time)\n    }\n  }\n\n  update(time, g) {}  // Update state that depends on time\n  draw(g, time) {}    // Draw to graphics context g\n\n  remove() {\n    if (this.parent) {\n      this.parent.remove(this)\n    }\n  }\n  pointFromSceneSpace(p) {\n    if (this.parent) {\n      return this.parent.pointFromSceneSpace(p)\n    }\n    return p\n  }\n  hitTest(p) {\n    return null\n  }\n}\n\n\nexport class DrawableNode extends Node {\n  constructor(position, fill, stroke) {\n    super(position)\n    this.interactive = true  // participates in hit testing\n    this.position = position || vec(0,0)\n    this.fill = fill === undefined ? \"white\" : fill\n    if (typeof stroke == \"string\") {\n      stroke = new Stroke(stroke, 1)\n    }\n    this.stroke = stroke || null\n  }\n\n  draw(g) {\n    g.fillStyle = this.fill\n    if (this.stroke) {\n      g.strokeStyle = this.stroke.color\n      g.lineWidth   = this.stroke.weight\n    }\n  }\n\n  hitTest(p) {\n    // log(`${this.constructor.name}.hitTest p=${p} bounds=${this.bounds}`)\n    if (this.interactive && this.bounds.containsPoint(p)) {\n      return new HitEvent(this, p)\n    }\n    return null\n  }\n}\n", "import { Node } from \"./index\"\n\nexport class GroupNode extends Node {\n  constructor(position, children) {\n    super(position)\n    this.children = new Set(children)\n  }\n\n  add(n) {\n    if (n.parent) {\n      n.parent.remove(n)\n    }\n    this.children.add(n)\n    n.parent = this\n    return n\n  }\n\n  remove(n) {\n    if (this.children.delete(n)) {\n      n.parent = null\n    }\n  }\n\n  updateAndDraw(g, time) {\n    if (!this.visible) {\n      return\n    }\n    if (this.needsRecompute) {\n      this.recompute()\n    }\n    let prevtr = g.getTransform()\n    g.translate(this.position.x, this.position.y)\n    this.update(time, g)\n    for (let n of this.children) {\n      n.updateAndDraw(g, time)\n    }\n    g.setTransform(prevtr)\n  }\n\n  pointFromSceneSpace(p) {\n    return p.sub(this.position)\n  }\n\n  hitTest(p) {\n    p = p.sub(this.position)\n    for (let n of this.children) {\n      let ev = n.hitTest(p)\n      if (ev) {\n        return ev\n      }\n    }\n    return null\n  }\n}\n", "import { vec } from \"../math\"\nimport { DrawableNode } from \"./node\"\n\nexport class LineNode extends DrawableNode {\n  constructor(start, end, stroke) {\n    super(start, null, stroke || Stroke.default)\n    this.end = end || vec(0, 0)\n  }\n\n  draw(g) {\n    super.draw(g)\n    g.beginPath()\n    g.moveTo(this.position.x, this.position.y)\n    g.lineTo(this.end.x, this.end.y)\n    g.stroke()\n  }\n\n  get length() {\n    return this.position.distanceTo(this.end)\n  }\n\n  set length(len) {\n    let angle = this.position.angleTo(this.end)\n    this.end = vec(\n      this.position.x + len * Math.cos(angle),\n      this.position.y + len * Math.sin(angle)\n    )\n  }\n\n  rotate(degrees) {\n    let radians = (Math.PI / 180) * degrees\n    let cos = Math.cos(radians)\n    let sin = Math.sin(radians)\n    let p1 = this.position\n    let p2 = this.end\n    this.end = vec(\n      (cos * (p2.x - p1.x)) + (sin * (p2.y - p1.y)) + p1.x,\n      (cos * (p2.y - p1.y)) - (sin * (p2.x - p1.x)) + p1.y\n    )\n  }\n\n  hitTest(p) { return null }\n}\n\n\nexport class DiscNode extends DrawableNode {\n  constructor(position, radius, fill, stroke) {\n    super(position, fill, stroke)\n    this.radius = radius || 10\n    this.size = this.radius * 2\n  }\n\n  recompute() {\n    super.recompute()\n    this.bounds.x = this.position.x - this.radius\n    this.bounds.y = this.position.y - this.radius\n    this.bounds.width = this.radius * 2\n    this.bounds.height = this.radius * 2\n  }\n\n  draw(g) {\n    super.draw(g)\n    g.beginPath()\n    g.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2, false)\n    g.closePath()\n    this.fill && g.fill()\n    this.stroke && g.stroke()\n  }\n}\n\n", "import { vec } from \"../math\"\nimport { DrawableNode } from \"./node\"\n\nexport class CubicBezierNode extends DrawableNode {\n  constructor(start, c1, c2, end, stroke) {\n    super(start, null, stroke || Stroke.default)\n    this.c1 = c1\n    this.c2 = c2\n    this.end = end\n    this.interpolationData = {x1:0,x2:0,x3:0,x4:0, y1:0,y2:0,y3:0,y4:0}\n  }\n\n  recompute() {\n    super.recompute()\n    this.updateInterpolationData()\n  }\n\n  updateInterpolationData() {\n    const D = this.interpolationData\n    let a = this.position.x, b = this.c1.x, c = this.c2.x, d = this.end.x\n    D.x1 = d - (3.0 * c) + (3.0 * b) - a\n    D.x2 = (3.0 * c) - (6.0 * b) + (3.0 * a)\n    D.x3 = (3.0 * b) - (3.0 * a)\n    D.x4 = a\n    a = this.position.y, b = this.c1.y, c = this.c2.y, d = this.end.y\n    D.y1 = d - (3.0 * c) + (3.0 * b) - a\n    D.y2 = (3.0 * c) - (6.0 * b) + (3.0 * a)\n    D.y3 = (3.0 * b) - (3.0 * a)\n    D.y4 = a\n  }\n\n  pointAt(t) {  // t [0-1]\n    const D = this.interpolationData\n    return vec(\n      ( D.x1*t*t*t + D.x2*t*t + D.x3*t + D.x4 ),\n      ( D.y1*t*t*t + D.y2*t*t + D.y3*t + D.y4 )\n    )\n  }\n\n  normalAt(t) {\n    return this.tangentAt(t).rotate(90)\n  }\n\n  tangentAt(t) {\n    const D = this.interpolationData\n    return vec(\n      ( ( 3.0 * D.x1 * t* t ) + ( 2.0 * D.x2 * t ) + D.x3 ),\n      ( ( 3.0 * D.y1 * t* t ) + ( 2.0 * D.y2 * t ) + D.y3 )\n    )\n  }\n\n  // Find the closest point on a B\u00E9zier curve to p\n  // Returns [p :Vec, t :number]\n  closestPoint(p) {\n    // More samples increases the chance of being correct\n    let mindex = 0, samples = 25\n    for (let min = Infinity, i = samples + 1; i-- ;) {\n      let d2 = p.squaredDistanceTo(this.pointAt(i / samples))\n      if (d2 < min) {\n        min = d2\n        mindex = i\n      }\n    }\n\n    // Find a minimum point for a bounded function. May be a local minimum.\n    let minX = Math.max((mindex - 1) / samples, 0)\n    let maxX = Math.min((mindex + 1) / samples, 1)\n    let p2, t2 = 0\n    let f = t => {\n      t2 = t\n      p2 = this.pointAt(t)\n      return p.squaredDistanceTo(p2)\n    }\n    let e = 1e-4\n    let k = 0.0\n    while ((maxX - minX) > e) {\n      k = (maxX + minX) / 2\n      if (f(k - e) < f(k + e)) {\n        maxX = k\n      } else {\n        minX = k\n      }\n    }\n    return [p2, t2]\n  }\n\n  draw(g) {\n    super.draw(g)\n    g.beginPath()\n    g.moveTo(this.position.x, this.position.y)\n    g.bezierCurveTo(this.c1.x, this.c1.y, this.c2.x, this.c2.y, this.end.x, this.end.y)\n    g.strokeStyle = this.stroke.color\n    g.lineWidth = this.stroke.weight\n    g.stroke()\n  }\n}\n", "export { Node, DrawableNode, Stroke } from \"./node\"\nexport { GroupNode } from \"./group\"\nexport { LineNode, DiscNode } from \"./primitives\"\nexport { CubicBezierNode } from \"./bezier\"\n", "import { Vec, vec } from \"./math\"\nimport { GroupNode } from \"./node\"\n\n\nexport class HitEvent {\n  constructor(node, point, scenePoint) {\n    this.node = node\n    this.point = point  // in node's coordinate system\n    this.scenePoint = scenePoint // updated by Scene in case of scene origin\n  }\n}\n\n\nexport class Scene extends EventEmitter {\n  constructor(renderer) {\n    super()\n    this.renderer = renderer\n    this.width  = renderer.canvas.width\n    this.height = renderer.canvas.height\n    this.pointer = vec(0,0)\n    this.pointerDownAt = vec(0,0)  // pointer value of last pointerdown event\n    this.root = new GroupNode()\n    this._eventHandlers = {}\n  }\n\n  enableHitTesting() {\n    let pointerDownEvent = null\n    this.addEventListener(\"pointerdown\", () => {\n      if (pointerDownEvent = this.hitTest(this.pointer)) {\n        this.pointerDownAt.x = this.pointer.x\n        this.pointerDownAt.y = this.pointer.y\n        pointerDownEvent.node.dispatchEvent(\"pointerdown\", pointerDownEvent)\n      }\n    })\n    this.addEventListener(\"pointerup\", () => {\n      let hitevent = this.hitTest(this.pointer)\n      if (hitevent) {\n        hitevent.node.dispatchEvent(\"pointerup\", hitevent)\n        if (pointerDownEvent && hitevent.node !== pointerDownEvent.node) {\n          pointerDownEvent.node.dispatchEvent(\"pointerup\", hitevent)\n        }\n      } else if (pointerDownEvent) {\n        pointerDownEvent.node.dispatchEvent(\"pointerup\", new HitEvent(null, null))\n      }\n      pointerDownEvent = null\n    })\n  }\n\n  hitTest(p) {\n    return this.root.hitTest(p)\n  }\n\n  addEventListener(event, handler) {\n    let n = super.addEventListener(event, handler)\n    if (n == 1) {\n      // first handler added\n      this._addEventHandler(event)\n    }\n    return n\n  }\n\n  removeEventListener(event, handler) {\n    let n = super.removeEventListener(event, handler)\n    if (n == 0) {\n      // last handler removed\n      this._removeEventHandler(event)\n    }\n    return n\n  }\n\n  _addEventHandler(event) {\n    const events1 = {\n      \"pointermove\":1,\n      \"pointerleave\":1,\n      \"pointerenter\":1,\n      \"pointerdown\":1,\n      \"pointerup\":1,\n    }\n    if (!(event in events1)) {\n      throw new Error(`invalid event ${event}`)\n    }\n\n    let handler = (\n      event == \"pointermove\" ? ev => {\n        this.pointer.x = ev.x\n        this.pointer.y = ev.y\n        let delta = this.pointer.sub(this.pointerDownAt)\n        this.dispatchEvent(event, delta)\n      } : ev => {\n        this.pointer.x = ev.x\n        this.pointer.y = ev.y\n        this.dispatchEvent(event, this.pointer)\n      }\n    )\n    this.renderer.canvas.addEventListener(event, handler)\n    this._eventHandlers[event] = handler\n  }\n\n  _removeEventHandler(event) {\n    let handler = this._eventHandlers[event]\n    if (handler) {\n      delete this._eventHandlers[event]\n      this.renderer.canvas.removeEventListener(event, handler)\n    }\n  }\n\n  // localPointerPosition() {\n  //   let p = this.pointer\n  //   let m = this.renderer.g.getTransform()\n  //   if (m.e != 0 || m.f != 0) {\n  //     p = vec(p.x - (m.e / m.a), p.y - (m.f / m.d))\n  //   }\n  //   return p\n  // }\n\n  add(n) { return this.root.add(n) }\n  remove(n) { this.root.remove(n) }\n\n  updateAndDraw(g, time) {\n    g.clearRect(0, 0, this.width, this.height)\n    this.root.updateAndDraw(g, time)\n  }\n}\n\n", "export class Renderer extends EventEmitter {\n  constructor() {\n    super()\n    this.canvas = $('canvas')\n    this.g = this.canvas.getContext('2d')\n    this.scale = 1\n    this.updateScale()\n    this.resizeCanvasToWindow()\n    this._onWindowResize = () => {\n      this.updateScale()\n      this.resizeCanvasToWindow()\n      this.dispatchEvent(\"resize\")\n    }\n    window.addEventListener(\"resize\", this._onWindowResize)\n  }\n\n  finalize() {\n    window.removeEventListener(\"resize\", this._onWindowResize)\n  }\n\n  updateScale() {\n    this.scale = (window.devicePixelRatio || 1) / (\n      this.g.backingStorePixelRatio ||\n      this.g.webkitBackingStorePixelRatio ||\n      this.g.mozBackingStorePixelRatio ||\n      this.g.msBackingStorePixelRatio ||\n      this.g.oBackingStorePixelRatio ||\n      1\n    )\n  }\n\n  resizeCanvasToWindow() {\n    // this.resizeCanvas(window.innerWidth, window.innerWidth * (3/4))\n    this.resizeCanvas(window.innerWidth, window.innerWidth)\n  }\n\n  resizeCanvas(width, height) {\n    this.canvas.style.zoom = String(1 / this.scale)\n    this.canvas.width = width * this.scale\n    this.canvas.height = height * this.scale\n  }\n\n  render(scene, time) {\n    const g = this.g\n    g.setTransform(this.scale, 0, 0, this.scale, 0, 0)\n    if (scene.transform) {\n      g.transform(scene.transform)\n    }\n    scene.updateAndDraw(g, time)\n  }\n}\n", "import \"./global\"\nimport { Scene } from \"./scene\"\nimport { Renderer } from \"./render\"\nimport { vec } from \"./math\"\nimport { GroupNode, LineNode, DiscNode, CubicBezierNode, Stroke } from \"./node\"\n\nfunction setupScene(scene, renderer) {\n  let g = new GroupNode(vec(100,200))\n\n  let curve1 = g.add(new CubicBezierNode(\n    vec(250, 120),  // start\n    vec(290, -40),  // control 1\n    vec(300, 200),  // control 2\n    vec(400, 150),  // end\n    new Stroke(\"rgba(0,0,0,0.4)\", 1.5)\n  ))\n\n  // show bezier control points\n  let handleSize = 4\n  let c1Line = g.add(new LineNode(curve1.c1, curve1.position, \"rgba(0,0,0,0.1)\"))\n  let c2Line = g.add(new LineNode(curve1.c2, curve1.end, \"rgba(0,0,0,0.1)\"))\n  let curveStart = g.add(new DiscNode(curve1.position, handleSize, \"white\", \"rgba(0,30,200,0.5)\"))\n  let curveEnd = g.add(new DiscNode(curve1.end, handleSize, \"white\", \"rgba(0,30,200,0.5)\"))\n  let c1 = g.add(new DiscNode(curve1.c1, handleSize, \"white\", \"rgba(0,180,20,0.8)\"))\n  let c2 = g.add(new DiscNode(curve1.c2, handleSize, \"white\", \"rgba(0,180,20,0.8)\"))\n  function makeDraggable(n) {\n    let origFill = n.fill\n    const movePoint = movementDelta => {\n      let p = pointerDot.pointFromSceneSpace(scene.pointer)\n      n.position.x = p.x\n      n.position.y = p.y\n      n.dirty()\n      c1Line.dirty()\n      c2Line.dirty()\n      curve1.dirty()\n    }\n    n.on(\"pointerdown\", ev => {\n      n.fill = \"rgba(0,180,20,0.8)\"\n      scene.on(\"pointermove\", movePoint)\n    })\n    n.on(\"pointerup\", ev => {\n      n.fill = origFill\n      scene.off(\"pointermove\", movePoint)\n    })\n  }\n  makeDraggable(curveStart)\n  makeDraggable(curveEnd)\n  makeDraggable(c1)\n  makeDraggable(c2)\n\n  // pointer\n  let pointerp = vec(-1000,-1000)\n  let pointerPerimeter = g.add(new DiscNode(pointerp, 8, null, \"rgba(0,200,255,0.2)\"))\n  let pointerDot = g.add(new DiscNode(pointerp, 8, \"rgba(0,200,255,0.3)\"))\n  let pointerTangentLine = g.add(new LineNode(null, null, \"rgba(255,50,0,0.9)\"))\n  let pointerNormalLine = g.add(new LineNode(null, null, \"rgba(0,100,255,0.9)\"))\n  let pointerDotRay = g.add(new DiscNode(pointerp, 3, \"rgba(0,200,255,1)\"))\n\n  const pointerUpdate = movementDelta => {\n    pointerDot.position = pointerDot.pointFromSceneSpace(scene.pointer)\n\n    let [p1, t] = curve1.closestPoint(pointerDot.position)\n    pointerDotRay.position = p1\n\n    let d = pointerDot.position.distanceTo(pointerDotRay.position)\n\n    let p2 = p1.add(curve1.tangentAt(t))\n    pointerTangentLine.position = p1\n    pointerTangentLine.end = p2\n    pointerTangentLine.length = Math.max(40, d)  // adjust line to be fixed size\n\n    pointerNormalLine.position = p1\n    pointerNormalLine.end = p2\n    pointerNormalLine.rotate(90)\n    pointerNormalLine.length = Math.max(40, d)\n\n    pointerPerimeter.position = pointerDot.position\n    pointerPerimeter.radius = Math.max(pointerDot.radius, d)\n    pointerPerimeter.stroke.color = `rgba(0,200,255,${Math.max(0.1,20/d)})`\n  }\n  scene.on(\"pointermove\", pointerUpdate)\n  scene.on(\"pointerleave\", () => {\n    scene.removeEventListener(\"pointermove\", pointerUpdate)\n    pointerDotRay.visible = false\n    pointerDot.visible = false\n    pointerPerimeter.visible = false\n    pointerTangentLine.visible = false\n    pointerNormalLine.visible = false\n  })\n  scene.on(\"pointerenter\", () => {\n    scene.addEventListener(\"pointermove\", pointerUpdate)\n    pointerDotRay.visible = true\n    pointerDot.visible = true\n    pointerPerimeter.visible = true\n    pointerTangentLine.visible = true\n    pointerNormalLine.visible = true\n  })\n\n  // animated tangent & normal lines\n  let tangentLine = g.add(new LineNode(null, null, \"rgba(255,50,0,0.9)\"))\n  let normalLine = g.add(new LineNode(null, null, \"rgba(0,100,255,0.9)\"))\n  let dot = g.add(new DiscNode(null, 2, \"black\"))\n  tangentLine.update = time => {\n    let t = Math.abs(1 - (time % 4000) / 2000)\n    dot.position = curve1.pointAt(t)\n\n    let p1 = curve1.pointAt(t)\n\n    let vel = curve1.tangentAt(t)\n    let p2 = p1.add(vel.mul(/* reduce length */0.3))\n    tangentLine.position = p1\n    tangentLine.end = p2\n\n    normalLine.position = p1\n    normalLine.end = p2\n    normalLine.rotate(90)\n  }\n\n  scene.add(g)\n  scene.enableHitTesting()\n\n  // center group in scene\n  // scene.\n}\n\n\nfunction main() {\n  log(\"start\")\n  let renderer = new Renderer()\n  let scene = new Scene(renderer)\n  setupScene(scene)\n\n  let animate = true\n\n  function tick(time) {\n    renderer.render(scene, time)\n    if (animate) {\n      requestAnimationFrame(tick)\n    }\n  }\n\n  if (animate) {\n    requestAnimationFrame(tick)\n  } else {\n    tick(1200)\n  }\n}\n\n// window.addEventListener('DOMContentLoaded', main)\nmain()\n"],
  "mappings": "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",
  "names": []
}
